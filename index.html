<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Designer Pro - Zen Mode</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #ffffff;
        font-family: "Segoe UI", sans-serif;
        overflow: hidden;
      }
      #canvas-wrapper {
        width: 100vw;
        height: 100vh;
        background-image: radial-gradient(#cbd5e1 1.2px, transparent 1.2px);
        background-size: 25px 25px;
      }
      #editorCanvas {
        display: block;
        cursor: crosshair;
      }

      /* Top Left: Add Menu (Square & Persistent) */
      #add-menu-container {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 3000;
        border-radius: 4px;
        border-color: #000;
      }
      #add-trigger {
        width: 45px;
        height: 45px;
        background: #fff;
        color: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border-radius: 4px;
        border: 2px solid;
        border-color: #000;
      }
      #add-options {
        display: none;
        background: #fff;
        padding: 10px;
        border: 2px solid black;
        border-radius: 4px;
        margin-top: 5px;
        flex-direction: column;
        gap: 8px;
      }
      /* Keep the menu open on hover */
      #add-menu-container:hover #add-options {
        display: flex;
      }

      /* Top Right: Project Actions */
      #project-actions {
        position: fixed;
        top: 20px;
        right: 20px;
        display: flex;
        gap: 10px;
        z-index: 3000;
        width: 45px;
        height: 45px;
        background: #fff;
        color: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border-radius: 4px;
        border: 2px solid;
        border-color: #000;
      }
      .btn-circle {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 2px solid #333;
        background: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }

      /* Contextual Navbar (Black BG, White Icons) */
      #navbar {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #fff;
        color: #fff;
        border-radius: 8px;
        display: none;
        align-items: center;
        padding: 10px 20px;
        gap: 25px;
        z-index: 2000;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      .nav-item {
        cursor: pointer;
        display: flex;
        align-items: center;
        position: relative;
        color: #fff;
      }

      /* Width Dropdown with Scrollbar */
      #width-dropdown {
        display: none;
        position: absolute;
        top: 40px;
        left: 50%;
        transform: translateX(-50%);
        background: #fff;
        color: #000;
        border: 2px solid #000;
        border-radius: 4px;
        max-height: 150px;
        overflow-y: auto;
        width: 70px;
        z-index: 3000;
      }
      .width-option {
        padding: 8px;
        text-align: center;
        border-bottom: 1px solid #eee;
        font-size: 13px;
      }
      .width-option:hover {
        background: #f0f0f0;
      }

      /* Color Palette (Horizontal Dots) */
      #color-palette {
        display: none;
        position: absolute;
        top: 50px;
        left: 50%;
        transform: translateX(-50%);
        background: #e2e8f0;
        padding: 8px 15px;
        border-radius: 30px;
        align-items: center;
        gap: 10px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      .palette-color {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        border: 2px solid #fff;
        cursor: pointer;
      }

      .style-btn {
        background: transparent;
        color: #000;
        border: 2px solid #444;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        width: 100px;
        font-size: 14px;
        text-align: left;
      }
      .style-btn:hover {
        background: grey;
      }

      .add-line-btn {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <div id="add-menu-container">
      <div id="add-trigger"><i class="fa-solid fa-plus"></i></div>
      <div id="add-options">
        <button class="style-btn add-line-btn" onclick="addNewLine('straight')">
          Straight <img src="./line.svg" />
        </button>
        <button class="style-btn add-line-btn" onclick="addNewLine('step')">
          Step <img src="./curve.svg" />
        </button>
        <button class="style-btn add-line-btn" onclick="addNewLine('curved')">
          Curved <img src="./step.svg" />
        </button>
      </div>
    </div>

    <div id="project-actions">
      <div id="send-btn" onclick="downloadSVG()">
        <i class="fa-solid fa-square-arrow-up-right fa-xl"></i>
      </div>
    </div>

    <div id="navbar">
      <div class="nav-item" onclick="toggleMenu('width-dropdown')">
        <img src="./linewidth.svg" alt="" class="nav-item" />
        <div id="width-dropdown"></div>
      </div>

      <div class="nav-item" onclick="toggleMenu('color-palette')">
        <div
          id="active-color-swatch"
          style="
            width: 20px;
            height: 20px;
            border-radius: 20%;
            border: 1.5px solid black;
          "
        ></div>
        <div id="color-palette">
          <div
            class="palette-color"
            style="background: #3b82f6"
            onclick="updateActiveLine('#3b82f6', null)"
          ></div>
          <div
            class="palette-color"
            style="background: #22c55e"
            onclick="updateActiveLine('#22c55e', null)"
          ></div>
          <div
            class="palette-color"
            style="background: #eab308"
            onclick="updateActiveLine('#eab308', null)"
          ></div>
          <div
            class="palette-color"
            style="background: #ef4444"
            onclick="updateActiveLine('#ef4444', null)"
          ></div>
          <div
            class="palette-color"
            style="background: #000000"
            onclick="updateActiveLine('#000000', null)"
          ></div>
          <div
            class="palette-color"
            style="background: #ffffff"
            onclick="updateActiveLine('#ffffff', null)"
          ></div>
        </div>
      </div>

      <div
        class="nav-item"
        onclick="toggleLock()"
        id="navLockBtn"
        style="color: #000"
      >
        <i class="fa-solid fa-unlock fa-xl"></i>
      </div>
      <div class="nav-item" onclick="deleteActiveLine()" style="color: #ef4444">
        <i class="fa-solid fa-xmark fa-xl"></i>
      </div>
    </div>

    <div id="canvas-wrapper"><canvas id="editorCanvas"></canvas></div>

    <script>
      const canvas = document.getElementById("editorCanvas");
      const ctx = canvas.getContext("2d");
      let lines = [],
        activeId = null,
        dragging = null,
        hoveredLineId = null;

      // Populate Width Dropdown
      const widthDrop = document.getElementById("width-dropdown");
      for (let i = 1; i <= 50; i=i+2) {
        const opt = document.createElement("div");
        opt.className = "width-option";
        opt.innerText = i + "px";
        opt.onclick = (e) => {
          e.stopPropagation();
          updateActiveLine(null, i);
          toggleMenu("width-dropdown");
        };
        widthDrop.appendChild(opt);
      }

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render();
      }
      window.onresize = resize;
      resize();

      function toggleMenu(id) {
        const el = document.getElementById(id);
        const current = el.style.display;
        document.getElementById("width-dropdown").style.display = "none";
        document.getElementById("color-palette").style.display = "none";
        el.style.display =
          current === "flex" || current === "block"
            ? "none"
            : id === "color-palette"
              ? "flex"
              : "block";
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        lines.forEach((line) => {
          const pts = [line.start, ...line.elbows, line.end];
          const path = new Path2D(getPath(pts));

          if (line.id === activeId || line.id === hoveredLineId) {
            ctx.strokeStyle = "#c031ff";
            ctx.lineWidth = line.width + 4;
            ctx.stroke(path);
          }

          ctx.strokeStyle = line.color;
          ctx.lineWidth = line.width;
          ctx.lineCap = ctx.lineJoin = "round";
          ctx.stroke(path);

          if (line.id === activeId) {
            const box = getBoundingBox(line);
            drawIcon(box.midX - 40, box.minY - 45, "move");
            drawIcon(
              box.midX,
              box.minY - 45,
              line.locked ? "locked" : "unlock",
            );
            drawIcon(box.midX + 40, box.minY - 45, "rotate");

            // Render Handles and Delete Buttons
            [line.start, line.end].forEach((p) => {
              drawHandle(p.x, p.y);
            });

            line.elbows.forEach((p) => {
              drawHandle(p.x, p.y);
              // Delete Button: Red circle with white X
              ctx.fillStyle = "#ef4444";
              ctx.beginPath();
              ctx.arc(p.x + 15, p.y - 15, 8, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = "#fff";
              ctx.font = "bold 10px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText("âœ•", p.x + 15, p.y - 15);
            });
          }
        });
      }

      function drawHandle(x, y) {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }

      function drawIcon(x, y, type) {
        const size = 30; // Increased slightly for better padding
        ctx.save();
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = "#000";
        ctx.fillStyle = "#fff";

        // Fill background so the line doesn't show through the icon
        ctx.fillRect(x - size / 2, y - size / 2, size, size);
        ctx.strokeRect(x - size / 2, y - size / 2, size, size);

        ctx.fillStyle = "#000";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle"; // This centers the glyph vertically
        ctx.font = "18px Arial";

        let icon =
          type === "move"
            ? "âœ¥"
            : type === "rotate"
              ? "â†»"
              : type === "locked"
                ? "ðŸ”’"
                : "ðŸ”“";

        // Drawing at (x, y) with 'middle' baseline puts the center of the text at y
        // We add a tiny 1px tweak if specific glyphs look too high or low
        const yOffset = type === "move" ? 0 : 1;
        ctx.fillText(icon, x, y + yOffset);

        ctx.restore();
      }

      function getPath(pts) {
        if (pts.length < 2) return "";
        let d = `M ${pts[0].x} ${pts[0].y}`;
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = i > 0 ? pts[i - 1] : pts[i];
          const p1 = pts[i];
          const p2 = pts[i + 1];
          const p3 = i < pts.length - 2 ? pts[i + 2] : p2;
          const cp1x = p1.x + (p2.x - p0.x) / 6;
          const cp1y = p1.y + (p2.y - p0.y) / 6;
          const cp2x = p2.x - (p3.x - p1.x) / 6;
          const cp2y = p2.y - (p3.y - p1.y) / 6;
          d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;
        }
        return d;
      }

      function getBoundingBox(line) {
        const all = [line.start, line.end, ...line.elbows];
        const minX = Math.min(...all.map((p) => p.x)),
          maxX = Math.max(...all.map((p) => p.x));
        return {
          minY: Math.min(...all.map((p) => p.y)),
          midX: (minX + maxX) / 2,
        };
      }

      function getLineAt(x, y) {
        // We iterate backwards to select the line "on top" first
        for (let i = lines.length - 1; i >= 0; i--) {
          const l = lines[i];
          const path = new Path2D(getPath([l.start, ...l.elbows, l.end]));

          // Create a wider invisible hit area (20px) for easier selection
          ctx.lineWidth = 20;
          if (ctx.isPointInStroke(path, x, y)) return l;
        }
        return null;
      }

      canvas.onmousedown = (e) => {
        const x = e.clientX,
          y = e.clientY;
        const activeLine = lines.find((l) => l.id === activeId);

        // 1. Check UI elements of the already active line first
        if (activeLine) {
          const box = getBoundingBox(activeLine);

          // Check Lock/Move/Rotate Icons
          if (Math.hypot(x - box.midX, y - (box.minY - 45)) < 15) {
            toggleLock();
            return;
          }

          if (!activeLine.locked) {
            // Check Delete Buttons for Elbows
            for (let i = 0; i < activeLine.elbows.length; i++) {
              const p = activeLine.elbows[i];
              if (Math.hypot(x - (p.x + 15), y - (p.y - 15)) < 10) {
                activeLine.elbows.splice(i, 1);
                render();
                return;
              }
            }
            // Check Draggable Points (Start, End, Elbows)
            const p = [
              activeLine.start,
              activeLine.end,
              ...activeLine.elbows,
            ].find((pt) => Math.hypot(x - pt.x, y - pt.y) < 15);
            if (p) {
              dragging = { type: "point", ref: p };
              return;
            }

            // Check Move/Rotate Icons
            if (Math.hypot(x - (box.midX - 40), y - (box.minY - 45)) < 15) {
              dragging = { type: "line", line: activeLine, lx: x, ly: y };
              return;
            }
            if (Math.hypot(x - (box.midX + 40), y - (box.minY - 45)) < 15) {
              const c = {
                x: (activeLine.start.x + activeLine.end.x) / 2,
                y: (activeLine.start.y + activeLine.end.y) / 2,
              };
              dragging = {
                type: "rotate",
                line: activeLine,
                center: c,
                sa: Math.atan2(y - c.y, x - c.x),
              };
              return;
            }
          }
        }

        // 2. If no UI was clicked, try to select a new line
        const clickedLine = getLineAt(x, y);
        if (clickedLine) {
          setActive(clickedLine.id);
        } else {
          setActive(null);
        }
      };

      window.onmousemove = (e) => {
        const x = e.clientX,
          y = e.clientY;
        let cursor = "default";

        if (dragging) {
          cursor = "grabbing";
          if (dragging.type === "point") {
            dragging.ref.x = x;
            dragging.ref.y = y;
          } else if (dragging.type === "line") {
            const dx = x - dragging.lx,
              dy = y - dragging.ly;
            [
              dragging.line.start,
              dragging.line.end,
              ...dragging.line.elbows,
            ].forEach((p) => {
              p.x += dx;
              p.y += dy;
            });
            dragging.lx = x;
            dragging.ly = y;
          } else if (dragging.type === "rotate") {
            const na = Math.atan2(y - dragging.center.y, x - dragging.center.x);
            const diff = na - dragging.sa;
            [
              dragging.line.start,
              dragging.line.end,
              ...dragging.line.elbows,
            ].forEach((p) => {
              const dx = p.x - dragging.center.x,
                dy = p.y - dragging.center.y;
              p.x =
                dragging.center.x + dx * Math.cos(diff) - dy * Math.sin(diff);
              p.y =
                dragging.center.y + dx * Math.sin(diff) + dy * Math.cos(diff);
            });
            dragging.sa = na;
          }
        } else {
          const l = lines.find((l) => l.id === activeId);
          if (l && !l.locked) {
            // Check Points
            if (
              [l.start, l.end, ...l.elbows].some(
                (p) => Math.hypot(x - p.x, y - p.y) < 10,
              )
            ) {
              cursor = "grab";
            }
            // Check Delete Buttons
            if (
              l.elbows.some(
                (p) => Math.hypot(x - (p.x + 15), y - (p.y - 15)) < 10,
              )
            ) {
              cursor = "pointer";
            }
            // Check Controls
            const box = getBoundingBox(l);
            if (Math.hypot(x - box.midX, y - (box.minY - 45)) < 60)
              cursor = "pointer";
          }
          if (cursor === "default" && hoveredLineId) cursor = "pointer";
        }

        canvas.style.cursor = cursor;

        // Line Hover detection
        if (!dragging) {
          hoveredLineId = null;
          lines.forEach((l) => {
            const pts = [l.start, ...l.elbows, l.end];
            for (let i = 0; i < pts.length - 1; i++)
              if (pToSegDist(x, y, pts[i], pts[i + 1]) < 10)
                hoveredLineId = l.id;
          });
        }
        render();
      };

      window.onmouseup = () => (dragging = null);

      function setActive(id) {
        activeId = id ? Number(id) : null;
        const nav = document.getElementById("navbar");
        if (activeId) {
          const l = lines.find((l) => l.id === activeId);
          document.getElementById("active-color-swatch").style.background =
            l.color;
          document.getElementById("navLockBtn").innerHTML = l.locked
            ? '<i class="fa-solid fa-lock fa-lg" style="color:#3b82f6"></i>'
            : '<i class="fa-solid fa-unlock fa-lg"></i>';
          nav.style.display = "flex";
        } else {
          nav.style.display = "none";
        }
        render();
      }

      function updateActiveLine(c, w) {
        const l = lines.find((l) => l.id === activeId);
        if (!l) return;
        if (c) {
          l.color = c;
          document.getElementById("active-color-swatch").style.background = c;
        }
        if (w) l.width = w;
        render();
      }

      function toggleLock() {
        const l = lines.find((l) => l.id === activeId);
        if (l) {
          l.locked = !l.locked;
          setActive(l.id);
        }
      }

      function deleteActiveLine() {
        lines = lines.filter((l) => l.id !== activeId);
        setActive(null);
      }

      function addNewLine(type) {
        const id = Date.now();
        let newLine = {
          id,
          color: "#3B82F6",
          width: 6,
          start: { x: 200, y: 300 },
          end: { x: 500, y: 300 },
          elbows: [],
          locked: false,
        };
        if (type === "step") {
          newLine.elbows = [
            { x: 350, y: 300 },
            { x: 350, y: 450 },
          ];
          newLine.end = { x: 500, y: 450 };
        } else if (type === "curved") {
          newLine.elbows = [{ x: 350, y: 200 }];
        }
        lines.push(newLine);
        setActive(id);
      }

      canvas.ondblclick = (e) => {
        // Use offsetX/Y for accurate canvas coordinates
        const x = e.offsetX;
        const y = e.offsetY;

        const l = lines.find((l) => l.id === activeId);
        if (!l || l.locked) return;

        // 1. Create a "hit area" path for the current line
        const pts = [l.start, ...l.elbows, l.end];
        const path = new Path2D(getPath(pts));

        // 2. Check if the double-click was actually ON the line
        // We use a wider lineWidth (20) just for the "hit test" to make it easier to click
        ctx.lineWidth = 20;
        if (ctx.isPointInStroke(path, x, y)) {
          // Find the best segment to insert the new point into
          const seq = [l.start, ...l.elbows, l.end];
          let bestIdx = -1;
          let minDist = 30;

          for (let i = 0; i < seq.length - 1; i++) {
            const d = pToSegDist(x, y, seq[i], seq[i + 1]);
            if (d < minDist) {
              minDist = d;
              bestIdx = i;
            }
          }

          if (bestIdx !== -1) {
            // Insert the point into the elbows array at the correct index
            l.elbows.splice(bestIdx, 0, { x, y });
            render();
          }
        }
      };

      function pToSegDist(x, y, a, b) {
        const l2 = (a.x - b.x) ** 2 + (a.y - b.y) ** 2;
        if (l2 === 0) return Math.hypot(x - a.x, y - a.y);
        const t = Math.max(
          0,
          Math.min(1, ((x - a.x) * (b.x - a.x) + (y - a.y) * (b.y - a.y)) / l2),
        );
        return Math.hypot(
          x - (a.x + t * (b.x - a.x)),
          y - (a.y + t * (b.y - a.y)),
        );
      }

      function downloadSVG() {
        const paths = lines
          .map(
            (l) =>
              `<path d="${getPath([l.start, ...l.elbows, l.end])}" fill="none" stroke="${l.color}" stroke-width="${l.width}" />`,
          )
          .join("");
        const blob = new Blob(
          [`<svg xmlns="http://www.w3.org/2000/svg">${paths}</svg>`],
          { type: "image/svg+xml" },
        );
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "drawing.svg";
        a.click();
      }
    </script>
  </body>
</html>
