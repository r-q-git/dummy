<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Designer Pro - Slider Fix</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #ffffff;
        font-family: "Segoe UI", sans-serif;
        overflow: hidden;
      }
      #canvas-wrapper {
        width: 100vw;
        height: 100vh;
        background-image: radial-gradient(#cbd5e1 1.2px, transparent 1.2px);
        background-size: 25px 25px;
      }
      #editorCanvas {
        display: block;
        cursor: crosshair;
      }

      #navbar {
        position: fixed;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        width: 80px;
        background: white;
        border: 2.5px solid #000;
        border-radius: 40px;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px 0;
        gap: 12px;
        z-index: 2000;
        box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.1);
      }

      .nav-item {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: 2px solid #333;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        position: relative;
        background: white;
        transition: 0.15s;
      }
      .nav-item:hover {
        background: #f8fafc;
        transform: scale(1.05);
      }

      #lineSelect {
        width: 100%;
        border: none;
        font-weight: bold;
        font-size: 14px;
        background: transparent;
        outline: none;
        text-align: center;
        cursor: pointer;
        appearance: none;
      }
      .color-circle {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: 1.5px solid #000;
      }
      input[type="color"] {
        position: absolute;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
      }

      /* FIXED SLIDER CSS */
      .size-popup {
        position: absolute;
        left: 55px; /* Moved closer to the nav-item */
        padding-left: 20px; /* Transparent bridge to keep hover active */
        display: none;
        flex-direction: column;
        z-index: 3000;
      }

      .size-popup-content {
        background: white;
        border: 2px solid #000;
        padding: 12px;
        border-radius: 12px;
        width: 130px;
        box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
      }

      .nav-item:hover .size-popup {
        display: flex;
      }

      .btn-red {
        border-color: #ef4444;
        color: #ef4444;
      }

      .style-btn {
        background: #f1f5f9;
        border: 1.5px solid #000;
        margin-bottom: 5px;
        padding: 5px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        font-size: 11px;
      }
      .style-btn:hover {
        background: #e2e8f0;
      }
      #plus-button:hover .size-popup {
        display: flex;
      }
    </style>
  </head>
  <body>
    <div id="navbar">
      <div class="nav-item" title="Add Line" id="plus-button">
        <i class="fa-solid fa-plus"></i>
        <div class="size-popup">
          <div class="size-popup-content">
            <label style="font-size: 10px; font-weight: 900; margin-bottom: 8px"
              >CHOOSE STYLE</label
            >
            <button class="style-btn" onclick="addNewLine('straight')">
              Straight
            </button>
            <button class="style-btn" onclick="addNewLine('step')">
              Step/Elbow
            </button>
            <button class="style-btn" onclick="addNewLine('curved')">
              Curved
            </button>
          </div>
        </div>
      </div>
      <div
        class="nav-item"
        onclick="document.getElementById('svgInput').click()"
        title="Upload SVG"
      >
        <i class="fa-solid fa-upload"></i>
        <input
          type="file"
          id="svgInput"
          accept=".svg"
          style="display: none"
          onchange="restoreFromSVG(event)"
        />
      </div>
      <div class="nav-item">
        <select id="lineSelect" onchange="setActive(this.value)"></select>
      </div>
      <div class="nav-item">
        <div id="colorPreview" class="color-circle"></div>
        <input
          type="color"
          id="lineColor"
          oninput="updateActiveLine(this.value, null)"
        />
      </div>

      <div class="nav-item">
        <span style="font-size: 12px; font-weight: 900" id="sizeDisplay"
          >S5</span
        >
        <div class="size-popup">
          <div class="size-popup-content">
            <label style="font-size: 10px; font-weight: 900; margin-bottom: 8px"
              >LINE SIZE (1-20)</label
            >
            <input
              type="range"
              min="1"
              max="20"
              value="4"
              id="lineWidthInput"
              oninput="updateActiveLine(null, this.value)"
            />
          </div>
        </div>
      </div>

      <div class="nav-item" onclick="downloadSVG()" title="Download SVG">
        <i class="fa-solid fa-download"></i>
      </div>
      <div
        class="nav-item btn-red"
        onclick="deleteActiveLine()"
        title="Delete Active"
      >
        <i class="fa-solid fa-xmark"></i>
      </div>
      <div class="nav-item btn-red" onclick="deleteAll()" title="Clear Canvas">
        <i class="fa-solid fa-trash-can"></i>
      </div>
    </div>

    <div id="canvas-wrapper">
      <canvas id="editorCanvas"></canvas>
    </div>

    <script>
      const canvas = document.getElementById("editorCanvas");
      const ctx = canvas.getContext("2d");
      const GREEK = [
        "α",
        "β",
        "γ",
        "δ",
        "ε",
        "ζ",
        "η",
        "θ",
        "ι",
        "κ",
        "λ",
        "μ",
        "ν",
        "ξ",
        "ο",
        "π",
        "ρ",
        "σ",
        "τ",
        "υ",
        "φ",
        "χ",
        "ψ",
        "ω",
      ];
      let lines = [],
        activeId = null,
        dragging = null,
        hoveredPoint = null;

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render();
      }
      window.onresize = resize;
      resize();

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        lines.forEach((line) => {
          const pts = [line.start, ...line.elbows, line.end];
          ctx.strokeStyle = line.color;
          ctx.lineWidth = line.width;
          ctx.lineCap = ctx.lineJoin = "round";
          ctx.stroke(new Path2D(getPath(pts)));
          if (line.id === activeId) {
            drawHandle(line.start, line.color, "");
            drawHandle(line.end, line.color, "");
            line.elbows.forEach((p, i) => {
              const isHovered = hoveredPoint && hoveredPoint.idx === i;
              drawHandle(p, "#ebebeb", GREEK[i % GREEK.length], isHovered);
            });
            const box = getBoundingBox(line);
            drawIcon(box.midX - 25, box.minY - 40, "move");
            drawIcon(box.midX + 25, box.minY - 40, "rotate");
          }
        });
      }

      function drawHandle(p, color, label, showCross) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 12, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.fillStyle = "black";
        ctx.font = "18px Serif";
        ctx.textAlign = "center";
        ctx.fillText(label, p.x, p.y + 4);
        if (showCross) {
          ctx.strokeStyle = "red";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.x + 10, p.y + 10);
          ctx.lineTo(p.x + 22, p.y + 22);
          ctx.moveTo(p.x + 22, p.y + 10);
          ctx.lineTo(p.x + 10, p.y + 22);
          ctx.stroke();
        }
      }

      function drawIcon(x, y, type) {
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(x, y, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "grey";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.fillStyle = "#000";
        ctx.font = "16px Serif";
        ctx.textAlign = "center";
        ctx.fillText(type === "move" ? "✥" : "↻", x, y + 5);
      }

      function getPath(pts) {
        let d = `M ${pts[0].x} ${pts[0].y}`;
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = pts[i - 1] || pts[i],
            p1 = pts[i],
            p2 = pts[i + 1],
            p3 = pts[i + 2] || p2;
          d += ` C ${p1.x + (p2.x - p0.x) * 0.25} ${p1.y + (p2.y - p0.y) * 0.25}, ${p2.x - (p3.x - p1.x) * 0.25} ${p2.y - (p3.y - p1.y) * 0.25}, ${p2.x} ${p2.y}`;
        }
        return d;
      }

      function getBoundingBox(line) {
        const all = [line.start, line.end, ...line.elbows];
        return {
          minY: Math.min(...all.map((p) => p.y)),
          midX:
            (Math.min(...all.map((p) => p.x)) +
              Math.max(...all.map((p) => p.x))) /
            2,
        };
      }

      canvas.ondblclick = (e) => {
        const l = lines.find((l) => l.id === activeId);
        if (!l) return;
        const x = e.clientX,
          y = e.clientY;
        const seq = [l.start, ...l.elbows, l.end];
        let bestIdx = -1,
          minDist = 30;
        for (let i = 0; i < seq.length - 1; i++) {
          const d = pToSegDist(x, y, seq[i], seq[i + 1]);
          if (d < minDist) {
            minDist = d;
            bestIdx = i;
          }
        }
        if (bestIdx !== -1) {
          l.elbows.splice(bestIdx, 0, { x, y });
          render();
        }
      };

      canvas.onmousedown = (e) => {
        const x = e.clientX,
          y = e.clientY;
        const l = lines.find((l) => l.id === activeId);
        if (!l) return;
        if (hoveredPoint) {
          const p = l.elbows[hoveredPoint.idx];
          if (x > p.x + 8 && y > p.y + 8) {
            l.elbows.splice(hoveredPoint.idx, 1);
            hoveredPoint = null;
            render();
            return;
          }
        }
        const box = getBoundingBox(l);
        if (
          Math.sqrt((x - (box.midX - 25)) ** 2 + (y - (box.minY - 40)) ** 2) <
          18
        ) {
          dragging = { type: "line", line: l, lx: x, ly: y };
          return;
        }
        if (
          Math.sqrt((x - (box.midX + 25)) ** 2 + (y - (box.minY - 40)) ** 2) <
          18
        ) {
          const c = getCenter(l);
          dragging = {
            type: "rotate",
            line: l,
            center: c,
            sa: Math.atan2(y - c.y, x - c.x),
          };
          return;
        }
        const pts = [l.start, l.end, ...l.elbows];
        const p = pts.find(
          (pt) => Math.sqrt((x - pt.x) ** 2 + (y - pt.y) ** 2) < 15,
        );
        if (p) dragging = { type: "point", ref: p };
      };

      window.onmousemove = (e) => {
        const x = e.clientX,
          y = e.clientY;
        if (dragging) {
          if (dragging.type === "point") {
            dragging.ref.x = x;
            dragging.ref.y = y;
          } else if (dragging.type === "line") {
            const dx = x - dragging.lx,
              dy = y - dragging.ly;
            [
              dragging.line.start,
              dragging.line.end,
              ...dragging.line.elbows,
            ].forEach((p) => {
              p.x += dx;
              p.y += dy;
            });
            dragging.lx = x;
            dragging.ly = y;
          } else if (dragging.type === "rotate") {
            const na = Math.atan2(y - dragging.center.y, x - dragging.center.x);
            const diff = na - dragging.sa;
            [
              dragging.line.start,
              dragging.line.end,
              ...dragging.line.elbows,
            ].forEach((p) => {
              const dx = p.x - dragging.center.x,
                dy = p.y - dragging.center.y;
              p.x =
                dragging.center.x + dx * Math.cos(diff) - dy * Math.sin(diff);
              p.y =
                dragging.center.y + dx * Math.sin(diff) + dy * Math.cos(diff);
            });
            dragging.sa = na;
          }
          render();
        } else {
          const l = lines.find((l) => l.id === activeId);
          if (l) {
            let found = null;
            l.elbows.forEach((p, i) => {
              if (Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2) < 25)
                found = { idx: i };
            });
            if (JSON.stringify(found) !== JSON.stringify(hoveredPoint)) {
              hoveredPoint = found;
              render();
            }
          }
        }
      };

      window.onmouseup = () => (dragging = null);

      function pToSegDist(x, y, a, b) {
        const l2 = (a.x - b.x) ** 2 + (a.y - b.y) ** 2;
        const t = Math.max(
          0,
          Math.min(1, ((x - a.x) * (b.x - a.x) + (y - a.y) * (b.y - a.y)) / l2),
        );
        return Math.sqrt(
          (x - (a.x + t * (b.x - a.x))) ** 2 +
            (y - (a.y + t * (b.y - a.y))) ** 2,
        );
      }
      function getCenter(l) {
        const a = [l.start, l.end, ...l.elbows];
        return {
          x: a.reduce((s, p) => s + p.x, 0) / a.length,
          y: a.reduce((s, p) => s + p.y, 0) / a.length,
        };
      }

      function addNewLine(type = "straight") {
        const id = Date.now();
        const startX = 200,
          startY = 300;
        let newLine = {
          id,
          name: "L" + (lines.length + 1),
          color: "#000000",
          width: 4,
          start: { x: startX, y: startY },
          end: { x: startX + 384, y: startY },
          elbows: [],
        };

        // Mapping the Canva shapes to our internal Elbow points
        if (type === "step") {
          // This replicates the "Step" logic from your second SVG
          newLine.end = { x: startX + 384, y: startY + 80 };
          newLine.elbows = [
            { x: startX + 192, y: startY }, // First pivot
            { x: startX + 192, y: startY + 80 }, // Second pivot
          ];
        } else if (type === "curved") {
          // This replicates the "Arc" logic from your third SVG
          // We use one middle elbow point to force the curve upward
          newLine.end = { x: startX + 384, y: startY };
          newLine.elbows = [{ x: startX + 192, y: startY - 50 }];
        }
        // 'straight' remains default (no elbows)

        lines.push(newLine);
        setActive(id);
      }

      function setActive(id) {
        activeId = Number(id);
        const l = lines.find((l) => l.id === activeId);
        if (l) {
          document.getElementById("colorPreview").style.background = l.color;
          document.getElementById("sizeDisplay").innerText = "S" + l.width;
          document.getElementById("lineWidthInput").value = l.width;
        }
        updateSelector();
        render();
      }

      function updateActiveLine(color, width) {
        const l = lines.find((l) => l.id === activeId);
        if (!l) return;
        if (color) {
          l.color = color;
          document.getElementById("colorPreview").style.background = color;
        }
        if (width) {
          l.width = parseInt(width); // FIXED: Force integer
          document.getElementById("sizeDisplay").innerText = "S" + width;
        }
        render();
      }

      function updateSelector() {
        const sel = document.getElementById("lineSelect");
        sel.innerHTML = lines
          .map(
            (l) =>
              `<option value="${l.id}" ${l.id === activeId ? "selected" : ""}>${l.name}</option>`,
          )
          .join("");
      }

      function deleteActiveLine() {
        lines = lines.filter((l) => l.id !== activeId);
        if (lines.length) setActive(lines[0].id);
        else {
          activeId = null;
          updateSelector();
          render();
        }
      }

      function deleteAll() {
        if (confirm("Clear everything?")) {
          lines = [];
          activeId = null;
          updateSelector();
          render();
        }
      }

      function downloadSVG() {
        if (!lines.length) return;
        const svgPaths = lines
          .map((l) => {
            const meta = JSON.stringify({
              start: l.start,
              end: l.end,
              elbows: l.elbows,
            });
            return `<path d="${getPath([l.start, ...l.elbows, l.end])}" data-points='${meta}' fill="none" stroke="${l.color}" stroke-width="${l.width}" stroke-linecap="round" stroke-linejoin="round" />`;
          })
          .join("");
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}">${svgPaths}</svg>`;
        const blob = new Blob([svg], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "my-design.svg";
        a.click();
        URL.revokeObjectURL(url);
      }

      function restoreFromSVG(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          const parser = new DOMParser();
          const doc = parser.parseFromString(e.target.result, "image/svg+xml");
          const paths = doc.querySelectorAll("path");
          paths.forEach((path) => {
            const meta = path.getAttribute("data-points");
            if (meta) {
              const pts = JSON.parse(meta);
              lines.push({
                id: Date.now() + Math.random(),
                name: "L" + (lines.length + 1),
                ...pts,
                color: path.getAttribute("stroke"),
                width: parseInt(path.getAttribute("stroke-width")),
              });
            }
          });
          if (lines.length) setActive(lines[lines.length - 1].id);
          event.target.value = "";
        };
        reader.readAsText(file);
      }
      addNewLine("straight");
    </script>
  </body>
</html>
