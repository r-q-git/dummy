<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Designer Pro - Direct Select</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #ffffff;
        font-family: "Segoe UI", sans-serif;
        overflow: hidden;
      }
      #canvas-wrapper {
        width: 100vw;
        height: 100vh;
        background-image: radial-gradient(#cbd5e1 1.2px, transparent 1.2px);
        background-size: 25px 25px;
      }
      #editorCanvas {
        display: block;
        cursor: crosshair;
      }

      #navbar {
        position: fixed;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        width: 80px;
        background: white;
        border: 2.5px solid #000;
        border-radius: 40px;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px 0;
        gap: 12px;
        z-index: 2000;
        box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.1);
      }

      /* New Sidebar List */
      #lineListContainer {
        max-height: 150px;
        overflow-y: auto;
        width: 60px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        scrollbar-width: none;
      }
      .line-item {
        font-size: 11px;
        font-weight: 900;
        padding: 5px;
        border: 1.5px solid #333;
        border-radius: 8px;
        text-align: center;
        cursor: pointer;
        transition: 0.2s;
      }
      .line-item.active {
        background: #ff9100;
        color: white;
        border-color: #000;
      }

      .nav-item {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: 2px solid #333;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        position: relative;
        background: white;
        transition: 0.15s;
      }
      .nav-item:hover {
        background: #f8fafc;
        transform: scale(1.05);
      }

      .color-circle {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: 1.5px solid #000;
      }
      input[type="color"] {
        position: absolute;
        opacity: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
      }

      .size-popup {
        position: absolute;
        left: 55px;
        padding-left: 20px;
        display: none;
        flex-direction: column;
        z-index: 3000;
      }
      .size-popup-content {
        background: white;
        border: 2px solid #000;
        padding: 12px;
        border-radius: 12px;
        width: 130px;
        box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.1);
      }
      .nav-item:hover .size-popup {
        display: flex;
      }

      .style-btn {
        background: #f1f5f9;
        border: 1.5px solid #000;
        margin-bottom: 5px;
        padding: 5px;
        border-radius: 6px;
        cursor: pointer;
        width: 100%;
        font-weight: bold;
        font-size: 11px;
      }
      .btn-red {
        border-color: #ef4444;
        color: #ef4444;
      }
    </style>
  </head>
  <body>
    <div id="navbar">
      <div class="nav-item" id="plus-button">
        <i class="fa-solid fa-plus"></i>
        <div class="size-popup">
          <div class="size-popup-content">
            <label style="font-size: 10px; font-weight: 900; margin-bottom: 8px"
              >STYLE</label
            >
            <button class="style-btn" onclick="addNewLine('straight')">
              Straight
            </button>
            <button class="style-btn" onclick="addNewLine('step')">Step</button>
            <button class="style-btn" onclick="addNewLine('curved')">
              Curved
            </button>
          </div>
        </div>
      </div>

      <div id="lineListContainer"></div>

      <div class="nav-item">
        <div id="colorPreview" class="color-circle"></div>
        <input
          type="color"
          id="lineColor"
          oninput="updateActiveLine(this.value, null)"
        />
      </div>

      <div class="nav-item">
        <span style="font-size: 12px; font-weight: 900" id="sizeDisplay"
          >S5</span
        >
        <div class="size-popup">
          <div class="size-popup-content">
            <label style="font-size: 10px; font-weight: 900; margin-bottom: 8px"
              >SIZE</label
            >
            <input
              type="range"
              min="1"
              max="20"
              value="4"
              id="lineWidthInput"
              oninput="updateActiveLine(null, this.value)"
            />
          </div>
        </div>
      </div>

       <div class="nav-item btn-red" onclick="deleteActiveLine()">
        <i class="fa-solid fa-xmark"></i>
      </div>
      <div class="nav-item" onclick="downloadSVG()">
      <i class="fa-solid fa-paper-plane"></i>
      </div>
     
    </div>

    <div id="canvas-wrapper">
      <canvas id="editorCanvas"></canvas>
    </div>

    <script>
      const canvas = document.getElementById("editorCanvas");
      const ctx = canvas.getContext("2d");
      const GREEK = [
        "α",
        "β",
        "γ",
        "δ",
        "ε",
        "ζ",
        "η",
        "θ",
        "ι",
        "κ",
        "λ",
        "μ",
        "ν",
        "ξ",
        "ο",
        "π",
        "ρ",
        "σ",
        "τ",
        "υ",
        "φ",
        "χ",
        "ψ",
        "ω",
      ];
      let lines = [],
        activeId = null,
        dragging = null,
        hoveredPoint = null,
        hoveredLineId = null;

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render();
      }
      window.onresize = resize;
      resize();

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        lines.forEach((line) => {
          const pts = [line.start, ...line.elbows, line.end];
          const path = new Path2D(getPath(pts));

          // STRICT HOVER/ACTIVE HIGHLIGHT
          // Only shows highlight if mouse is actually over the line OR it's the active one
          if (line.id === activeId || line.id === hoveredLineId) {
            ctx.strokeStyle = "#FF9100";
            ctx.lineWidth = line.width + 5;
            ctx.lineCap = ctx.lineJoin = "round";
            ctx.stroke(path);
          }

          ctx.strokeStyle = line.color;
          ctx.lineWidth = line.width;
          ctx.lineCap = ctx.lineJoin = "round";
          ctx.stroke(path);

          if (line.id === activeId) {
            drawHandle(line.start, "#ffcc00", "+");
            drawHandle(line.end, "#ffcc00", "+");
            line.elbows.forEach((p, i) => {
              const isPtHovered = hoveredPoint && hoveredPoint.idx === i;
              drawHandle(p, "#ebebeb", GREEK[i % GREEK.length], isPtHovered);
            });
            const box = getBoundingBox(line);
            drawIcon(box.midX - 25, box.minY - 40, "move");
            drawIcon(box.midX + 25, box.minY - 40, "rotate");
          }
        });
      }

      canvas.ondblclick = (e) => {
        const x = e.clientX,
          y = e.clientY;
        const l = lines.find((l) => l.id === activeId);
        if (!l) return;

        const seq = [l.start, ...l.elbows, l.end];
        let bestIdx = -1,
          minDist = 20; // Tightened distance for better accuracy

        for (let i = 0; i < seq.length - 1; i++) {
          const d = pToSegDist(x, y, seq[i], seq[i + 1]);
          if (d < minDist) {
            minDist = d;
            bestIdx = i;
          }
        }

        if (bestIdx !== -1) {
          // Insert new elbow point between the two closest points
          l.elbows.splice(bestIdx, 0, { x, y });
          render();
        }
      };

      function drawHandle(p, color, label, showCross) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 12, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();

        ctx.fillStyle = "black";
        ctx.font = "bold 12px Sans";
        ctx.textAlign = "center";
        ctx.fillText(label, p.x, p.y + 4);

        // Offset the delete cross away from the line (Top-Right)
        if (showCross) {
          const offsetX = 18;
          const offsetY = -18;

          // Draw a small red circle background for the delete button
          ctx.beginPath();
          ctx.arc(p.x + offsetX, p.y + offsetY, 8, 0, Math.PI * 2);
          ctx.fillStyle = "#ef4444";
          ctx.fill();

          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          // Small white 'x'
          ctx.moveTo(p.x + offsetX - 4, p.y + offsetY - 4);
          ctx.lineTo(p.x + offsetX + 4, p.y + offsetY + 4);
          ctx.moveTo(p.x + offsetX + 4, p.y + offsetY - 4);
          ctx.lineTo(p.x + offsetX - 4, p.y + offsetY + 4);
          ctx.stroke();
        }
      }

      function drawIcon(x, y, type) {
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(x, y, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "grey";
        ctx.stroke();
        ctx.fillStyle = "#000";
        ctx.textAlign = "center";
        ctx.fillText(type === "move" ? "✥" : "↻", x, y + 5);
      }

      function getPath(pts) {
        let d = `M ${pts[0].x} ${pts[0].y}`;
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = pts[i - 1] || pts[i],
            p1 = pts[i],
            p2 = pts[i + 1],
            p3 = pts[i + 2] || p2;
          d += ` C ${p1.x + (p2.x - p0.x) * 0.25} ${p1.y + (p2.y - p0.y) * 0.25}, ${p2.x - (p3.x - p1.x) * 0.25} ${p2.y - (p3.y - p1.y) * 0.25}, ${p2.x} ${p2.y}`;
        }
        return d;
      }

      function getBoundingBox(line) {
        const all = [line.start, line.end, ...line.elbows];
        return {
          minY: Math.min(...all.map((p) => p.y)),
          midX:
            (Math.min(...all.map((p) => p.x)) +
              Math.max(...all.map((p) => p.x))) /
            2,
        };
      }

      // --- 3. Updated MouseDown to handle the Offset Delete Click ---
      canvas.onmousedown = (e) => {
        const x = e.clientX,
          y = e.clientY;
        const l = lines.find((l) => l.id === activeId);

        if (l && hoveredPoint) {
          const p = l.elbows[hoveredPoint.idx];
          const distToDelete = Math.hypot(x - (p.x + 18), y - (p.y - 18));

          // If clicking the specifically offset delete button
          if (distToDelete < 12) {
            l.elbows.splice(hoveredPoint.idx, 1);
            hoveredPoint = null;
            render();
            return;
          }
        }

        // Continue with normal dragging/selection logic...
        if (l) {
          const pts = [l.start, l.end, ...l.elbows];
          const p = pts.find((pt) => Math.hypot(x - pt.x, y - pt.y) < 15);
          if (p) {
            dragging = { type: "point", ref: p };
            return;
          }

          const box = getBoundingBox(l);
          if (Math.hypot(x - (box.midX - 25), y - (box.minY - 40)) < 18) {
            dragging = { type: "line", line: l, lx: x, ly: y };
            return;
          }
          if (Math.hypot(x - (box.midX + 25), y - (box.minY - 40)) < 18) {
            const c = getCenter(l);
            dragging = {
              type: "rotate",
              line: l,
              center: c,
              sa: Math.atan2(y - c.y, x - c.x),
            };
            return;
          }
        }

        if (hoveredLineId !== null) {
          setActive(hoveredLineId);
        }
      };

      window.onmousemove = (e) => {
        const x = e.clientX,
          y = e.clientY;
        let cursorType = "default";

        if (dragging) {
          cursorType = "grabbing"; // Hand closed while moving
          if (dragging.type === "point") {
            dragging.ref.x = x;
            dragging.ref.y = y;
          } else if (dragging.type === "line") {
            const dx = x - dragging.lx,
              dy = y - dragging.ly;
            [
              dragging.line.start,
              dragging.line.end,
              ...dragging.line.elbows,
            ].forEach((p) => {
              p.x += dx;
              p.y += dy;
            });
            dragging.lx = x;
            dragging.ly = y;
          } else if (dragging.type === "rotate") {
            const na = Math.atan2(y - dragging.center.y, x - dragging.center.x);
            const diff = na - dragging.sa;
            [
              dragging.line.start,
              dragging.line.end,
              ...dragging.line.elbows,
            ].forEach((p) => {
              const dx = p.x - dragging.center.x,
                dy = p.y - dragging.center.y;
              p.x =
                dragging.center.x + dx * Math.cos(diff) - dy * Math.sin(diff);
              p.y =
                dragging.center.y + dx * Math.sin(diff) + dy * Math.cos(diff);
            });
            dragging.sa = na;
          }
          render();
        } else {
          // Check for Hover on Lines
          let lineFound = null;
          lines.forEach((l) => {
            const pts = [l.start, ...l.elbows, l.end];
            for (let i = 0; i < pts.length - 1; i++) {
              if (pToSegDist(x, y, pts[i], pts[i + 1]) < 12) {
                lineFound = l.id;
                cursorType = "pointer"; // Hand icon when over a line
              }
            }
          });

          // Check for Hover on Elbow Points
          const activeL = lines.find((l) => l.id === activeId);
          let ptFound = null;
          if (activeL) {
            activeL.elbows.forEach((p, i) => {
              // Check if mouse is over the handle OR the offset delete button
              const distToHandle = Math.hypot(x - p.x, y - p.y);
              const distToDelete = Math.hypot(x - (p.x + 18), y - (p.y - 18));

              if (distToHandle < 15 || distToDelete < 10) {
                ptFound = { idx: i };
                cursorType = "pointer";
              }
            });
          }

          if (
            hoveredLineId !== lineFound ||
            JSON.stringify(ptFound) !== JSON.stringify(hoveredPoint)
          ) {
            hoveredLineId = lineFound;
            hoveredPoint = ptFound;
            render();
          }
        }

        canvas.style.cursor = cursorType;
      };

      window.onmouseup = () => (dragging = null);

      function pToSegDist(x, y, a, b) {
        const l2 = (a.x - b.x) ** 2 + (a.y - b.y) ** 2;
        if (l2 === 0) return Math.hypot(x - a.x, y - a.y);
        const t = Math.max(
          0,
          Math.min(1, ((x - a.x) * (b.x - a.x) + (y - a.y) * (b.y - a.y)) / l2),
        );
        return Math.hypot(
          x - (a.x + t * (b.x - a.x)),
          y - (a.y + t * (b.y - a.y)),
        );
      }

      function getCenter(l) {
        const a = [l.start, l.end, ...l.elbows];
        return {
          x: a.reduce((s, p) => s + p.x, 0) / a.length,
          y: a.reduce((s, p) => s + p.y, 0) / a.length,
        };
      }

      function addNewLine(type) {
        const id = Date.now();
        let newLine = {
          id,
          name: "L" + (lines.length + 1),
          color: "#000000",
          width: 4,
          start: { x: 200, y: 300 },
          end: { x: 584, y: 300 },
          elbows: [],
        };
        if (type === "step") {
          newLine.end.y += 80;
          newLine.elbows = [
            { x: 392, y: 300 },
            { x: 392, y: 380 },
          ];
        } else if (type === "curved") {
          newLine.elbows = [{ x: 392, y: 250 }];
        }
        lines.push(newLine);
        setActive(id);
      }

      function setActive(id) {
        activeId = Number(id);
        const l = lines.find((l) => l.id === activeId);
        if (l) {
          document.getElementById("colorPreview").style.background = l.color;
          document.getElementById("sizeDisplay").innerText = "S" + l.width;
          document.getElementById("lineWidthInput").value = l.width;
        }
        updateLineList();
        render();
      }

      function updateActiveLine(color, width) {
        const l = lines.find((l) => l.id === activeId);
        if (!l) return;
        if (color) {
          l.color = color;
          document.getElementById("colorPreview").style.background = color;
        }
        if (width) {
          l.width = parseInt(width);
          document.getElementById("sizeDisplay").innerText = "S" + width;
        }
        render();
      }

      function updateLineList() {
        const container = document.getElementById("lineListContainer");
        container.innerHTML = lines
          .map(
            (l) => `
          <div class="line-item ${l.id === activeId ? "active" : ""}" onclick="setActive(${l.id})">
            ${l.name}
          </div>
        `,
          )
          .join("");
      }

      function deleteActiveLine() {
        lines = lines.filter((l) => l.id !== activeId);
        if (lines.length) setActive(lines[0].id);
        else {
          activeId = null;
          updateLineList();
          render();
        }
      }

      function downloadSVG() {
        if (!lines.length) return;
        const svgPaths = lines
          .map((l) => {
            const meta = JSON.stringify({
              start: l.start,
              end: l.end,
              elbows: l.elbows,
            });
            return `<path d="${getPath([l.start, ...l.elbows, l.end])}" data-points='${meta}' fill="none" stroke="${l.color}" stroke-width="${l.width}" stroke-linecap="round" stroke-linejoin="round" />`;
          })
          .join("");
        const blob = new Blob(
          [
            `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}">${svgPaths}</svg>`,
          ],
          { type: "image/svg+xml" },
        );
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "design.svg";
        a.click();
      }

      addNewLine("straight");
    </script>
  </body>
</html>
