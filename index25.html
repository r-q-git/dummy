<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Designer Pro - Precise Restoration</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #cbd5e1;
        font-family: "Segoe UI", sans-serif;
      }
      #editorCanvas {
        display: block;
        background: white;
      }

      #floating-nav {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 95%;
        max-width: 1100px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.4);
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        padding: 12px 24px;
        gap: 15px;
        z-index: 1000;
      }

      .nav-section {
        display: flex;
        align-items: center;
        gap: 12px;
        border-right: 1px solid #e2e8f0;
        padding-right: 15px;
      }
      label {
        font-size: 10px;
        font-weight: 800;
        color: #64748b;
        text-transform: uppercase;
        display: block;
      }

      button {
        padding: 8px 14px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: 0.2s;
        font-size: 13px;
      }
      .btn-main {
        background: #6366f1;
        color: white;
      }
      .btn-restore {
        background: #f59e0b;
        color: white;
      }
      .btn-success {
        background: #10b981;
        color: white;
      }
      .btn-danger {
        background: #fee2e2;
        color: #ef4444;
      }

      .dropdown {
        position: relative;
      }
      .dropdown-content {
        display: none;
        position: absolute;
        top: 45px;
        left: 0;
        background: white;
        min-width: 180px;
        border-radius: 10px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        padding: 8px;
        z-index: 1001;
      }
      .dropdown:hover .dropdown-content {
        display: block;
      }

      .list-item {
        padding: 8px;
        font-size: 13px;
        cursor: pointer;
        border-radius: 5px;
      }
      .list-item:hover {
        background: #f1f5f9;
      }
      input[type="range"] {
        width: 70px;
      }
    </style>
  </head>
  <body>
    <nav id="floating-nav">
      <div class="nav-section">
        <button class="btn-main" onclick="addNewLine()">+ New Line</button>
        <button
          class="btn-restore"
          onclick="document.getElementById('svgInput').click()"
        >
          Restore File
        </button>
        <input
          type="file"
          id="svgInput"
          accept=".svg"
          style="display: none"
          onchange="restoreFromSVG(event)"
        />
      </div>

      <div class="nav-section">
        <div class="dropdown">
          <button
            style="
              background: #f1f5f9;
              border: none;
              border-radius: 8px;
              padding: 8px 14px;
              cursor: pointer;
            "
          >
            Manage Lines ▼
          </button>
          <div id="line-list" class="dropdown-content"></div>
        </div>
      </div>

      <div
        id="active-controls"
        style="display: none; align-items: center; gap: 15px"
      >
        <div class="nav-section">
          <div>
            <label>Color</label
            ><input type="color" id="lineColor" oninput="updateActiveLine()" />
          </div>
          <div>
            <label>Weight</label
            ><input
              type="range"
              id="lineWidth"
              min="2"
              max="100"
              oninput="updateActiveLine()"
            />
          </div>
          <div>
            <label>Scale</label
            ><input
              type="range"
              id="lineScale"
              min="10"
              max="300"
              value="100"
              oninput="scaleLine(this.value)"
            />
          </div>
        </div>

        <div class="nav-section">
          <div class="dropdown">
            <button
              style="
                background: #f1f5f9;
                border: none;
                border-radius: 8px;
                padding: 8px 14px;
                cursor: pointer;
              "
            >
              Greek Points ▼
            </button>
            <div id="bp-list" class="dropdown-content"></div>
          </div>
          <button
            class="btn-main"
            style="background: #3b82f6"
            onclick="addElbowToActive()"
          >
            + Point
          </button>
        </div>

        <button onclick="deleteActiveLine()" class="btn-danger">Delete</button>
      </div>

      <div style="margin-left: auto; display: flex; gap: 10px">
        <button
          style="background: #f1f5f9; color: #64748b"
          onclick="clearCanvas()"
        >
          Clear All
        </button>
        <button class="btn-success" onclick="downloadSVG()">
          Download SVG
        </button>
      </div>
    </nav>

    <canvas id="editorCanvas"></canvas>

    <script>
      const canvas = document.getElementById("editorCanvas");
      const ctx = canvas.getContext("2d");
      const GREEK = [
        "α",
        "β",
        "γ",
        "δ",
        "ε",
        "ζ",
        "η",
        "θ",
        "ι",
        "κ",
        "λ",
        "μ",
        "ν",
        "ξ",
        "ο",
        "π",
        "ρ",
        "σ",
        "τ",
        "υ",
        "φ",
        "χ",
        "ψ",
        "ω",
      ];

      let lines = [];
      let activeId = null;
      let dragging = null;
      let lastScale = 100;

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        render();
      }
      window.addEventListener("resize", resize);
      resize();

      function drawGrid() {
        ctx.fillStyle = "#94a3b8";
        for (let x = 0; x < canvas.width; x += 30) {
          for (let y = 0; y < canvas.height; y += 30) {
            ctx.fillRect(x, y, 1, 1);
          }
        }
      }

      // --- PRECISE RESTORATION LOGIC ---
      function restoreFromSVG(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          const doc = new DOMParser().parseFromString(
            e.target.result,
            "image/svg+xml",
          );
          const paths = doc.querySelectorAll("path");

          // Clear existing lines if you want a clean restore, or keep them to stack
          // lines = [];

          paths.forEach((path) => {
            const rawData = path.getAttribute("data-points");
            if (rawData) {
              const parsed = JSON.parse(rawData);
              const newLine = {
                id: Date.now() + Math.random(),
                name: "Restored Line " + (lines.length + 1),
                start: parsed.start,
                end: parsed.end,
                elbows: parsed.elbows,
                color: path.getAttribute("stroke") || "#6366f1",
                width: parseInt(path.getAttribute("stroke-width")) || 10,
              };
              lines.push(newLine);
            }
          });
          if (lines.length > 0) setActive(lines[lines.length - 1].id);
          event.target.value = ""; // Clear input to allow re-uploading same file
        };
        reader.readAsText(file);
      }

      function getPath(pts) {
        if (pts.length < 2) return "";
        let d = `M ${pts[0].x} ${pts[0].y}`;
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = pts[i - 1] || pts[i],
            p1 = pts[i],
            p2 = pts[i + 1],
            p3 = pts[i + 2] || p2;
          d += ` C ${p1.x + (p2.x - p0.x) * 0.25} ${p1.y + (p2.y - p0.y) * 0.25}, ${p2.x - (p3.x - p1.x) * 0.25} ${p2.y - (p3.y - p1.y) * 0.25}, ${p2.x} ${p2.y}`;
        }
        return d;
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        lines.forEach((line) => {
          const pts = [line.start, ...line.elbows, line.end];
          ctx.strokeStyle = line.color;
          ctx.lineWidth = line.width;
          ctx.lineCap = ctx.lineJoin = "round";
          ctx.stroke(new Path2D(getPath(pts)));

          if (line.id === activeId) {
            drawHandle(line.start, "#3b82f6", "S");
            drawHandle(line.end, "#3b82f6", "E");
            line.elbows.forEach((p, i) =>
              drawHandle(p, "#ff4444", GREEK[i % GREEK.length]),
            );
            const midX = (line.start.x + line.end.x) / 2,
              midY = (line.start.y + line.end.y) / 2 - 60;
            drawMoveHandle(midX, midY);
          }
        });
      }

      function drawHandle(p, color, label) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 11, 0, 7);
        ctx.fillStyle = "white";
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = color;
        ctx.font = "bold 11px Arial";
        ctx.textAlign = "center";
        ctx.fillText(label, p.x, p.y + 4);
      }

      function drawMoveHandle(x, y) {
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, 14, 0, 7);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x - 8, y);
        ctx.lineTo(x + 8, y);
        ctx.moveTo(x, y - 8);
        ctx.lineTo(x, y + 8);
        ctx.stroke();
      }

      function scaleLine(value) {
        const line = lines.find((l) => l.id === activeId);
        if (!line) return;
        const factor = value / lastScale;
        lastScale = value;
        const allPts = [line.start, line.end, ...line.elbows];
        const cX = allPts.reduce((s, p) => s + p.x, 0) / allPts.length;
        const cY = allPts.reduce((s, p) => s + p.y, 0) / allPts.length;
        allPts.forEach((p) => {
          p.x = cX + (p.x - cX) * factor;
          p.y = cY + (p.y - cY) * factor;
        });
        render();
        updateLists();
      }

      canvas.onmousedown = (e) => {
        const x = e.clientX,
          y = e.clientY;
        const l = lines.find((l) => l.id === activeId);
        if (l) {
          const midX = (l.start.x + l.end.x) / 2,
            midY = (l.start.y + l.end.y) / 2 - 60;
          if (Math.sqrt((x - midX) ** 2 + (y - midY) ** 2) < 20) {
            dragging = { type: "line", line: l, lastX: x, lastY: y };
            return;
          }
          const pts = [l.start, l.end, ...l.elbows];
          const p = pts.find(
            (p) => Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2) < 18,
          );
          if (p) dragging = { type: "point", ref: p };
        }
      };

      window.onmousemove = (e) => {
        if (!dragging) return;
        const x = e.clientX,
          y = e.clientY;
        if (dragging.type === "point") {
          dragging.ref.x = x;
          dragging.ref.y = y;
        } else {
          const dx = x - dragging.lastX,
            dy = y - dragging.lastY;
          [
            dragging.line.start,
            dragging.line.end,
            ...dragging.line.elbows,
          ].forEach((p) => {
            p.x += dx;
            p.y += dy;
          });
          dragging.lastX = x;
          dragging.lastY = y;
        }
        render();
        updateLists();
      };
      window.onmouseup = () => (dragging = null);

      function addNewLine() {
        const id = Date.now();
        lines.push({
          id,
          name: "Line " + (lines.length + 1),
          start: { x: window.innerWidth / 2 - 100, y: window.innerHeight / 2 },
          end: { x: window.innerWidth / 2 + 100, y: window.innerHeight / 2 },
          elbows: [],
          color: "#6366f1",
          width: 10,
        });
        setActive(id);
      }

      function setActive(id) {
        activeId = id;
        lastScale = 100;
        const s = document.getElementById("lineScale");
        if (s) s.value = 100;
        updateLists();
        render();
      }

      function updateLists() {
        const list = document.getElementById("line-list");
        list.innerHTML = lines
          .map(
            (l) =>
              `<div class="list-item" style="${l.id === activeId ? "color:#6366f1;font-weight:bold" : ""}" onclick="setActive(${l.id})">${l.name}</div>`,
          )
          .join("");
        const activeLine = lines.find((l) => l.id === activeId);
        const ctrl = document.getElementById("active-controls");
        if (activeLine) {
          ctrl.style.display = "flex";
          document.getElementById("lineColor").value = activeLine.color;
          document.getElementById("lineWidth").value = activeLine.width;
          document.getElementById("bp-list").innerHTML = activeLine.elbows
            .map(
              (ep, i) =>
                `<div class="list-item" style="display:flex; justify-content:space-between"><span>Point ${GREEK[i]}</span><span onclick="deleteBreakpoint(${i})" style="color:red">✖</span></div>`,
            )
            .join("");
        } else {
          ctrl.style.display = "none";
        }
      }

      function deleteBreakpoint(i) {
        lines.find((l) => l.id === activeId).elbows.splice(i, 1);
        updateLists();
        render();
      }
      function deleteActiveLine() {
        lines = lines.filter((l) => l.id !== activeId);
        setActive(lines.length ? lines[0].id : null);
      }
      function updateActiveLine() {
        const l = lines.find((l) => l.id === activeId);
        l.color = document.getElementById("lineColor").value;
        l.width = parseInt(document.getElementById("lineWidth").value);
        render();
      }
      function addElbowToActive() {
        const l = lines.find((l) => l.id === activeId);
        l.elbows.push({
          x: (l.start.x + l.end.x) / 2,
          y: (l.start.y + l.end.y) / 2 - 80,
        });
        updateLists();
        render();
      }
      function clearCanvas() {
        lines = [];
        activeId = null;
        updateLists();
        render();
      }
      function downloadSVG() {
        let svgPaths = lines
          .map((l) => {
            const pointData = JSON.stringify({
              start: l.start,
              end: l.end,
              elbows: l.elbows,
            });
            return `<path d="${getPath([l.start, ...l.elbows, l.end])}" data-points='${pointData}' fill="none" stroke="${l.color}" stroke-width="${l.width}" stroke-linecap="round" stroke-linejoin="round" />`;
          })
          .join("");
        const blob = new Blob(
          [
            `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}">${svgPaths}</svg>`,
          ],
          { type: "image/svg+xml" },
        );
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "perfect-restore.svg";
        a.click();
      }

      addNewLine();
    </script>
  </body>
</html>
